import { z } from 'zod';

/**
 * @fileOverview This file contains shared Zod schemas for Genkit flows.
 * It does not have a "use server" directive and can be safely imported
 * into both server and client components. This ensures a single source of truth
 * for our data structures across the application.
 */

/**
 * Defines the schema for a single character, including their name and a
 * description generated by the AI based on the story's context.
 * It now also includes the AI-selected voiceId.
 */
export const CharacterSchema = z.object({
  name: z.string().describe('The name of the character.'),
  description: z
    .string()
    .describe(
      'A physical description of the character based on the story text.'
    ),
  voiceId: z.string().optional().describe('The voice ID assigned to this character by the AI casting director.'),
});
export type Character = z.infer<typeof CharacterSchema>;

/**
 * Defines the schema for a single segment of the story, which can be
 * either dialogue spoken by a character or narrative text. It includes the
 * inferred emotion for the segment, which guides the TTS performance.
 */
export const DialogueSegmentSchema = z.object({
  character: z
    .string()
    .describe(
      'The name of the character speaking, or "Narrator" for narrative text.'
    ),
  dialogue: z
    .string()
    .describe('The dialogue spoken by the character, or narrative text.'),
  emotion: z
    .string()
    .describe(
      'The primary emotion conveyed by the dialogue (e.g., Happy, Sad, Angry, Intrigued, Worried). For the Narrator, this can be "Neutral" or reflect the scene\'s mood.'
    ),
});
export type DialogueSegment = z.infer<typeof DialogueSegmentSchema>;

/**
 * Defines the schema for a single emotional tone analysis, including the
 * emotion, the quote where it appears, and an explanation.
 */
export const EmotionalToneSchema = z.object({
    emotion: z.string().describe('The name of the emotional tone.'),
    quote: z.string().describe('The specific quote from the text that has the emotional tone.'),
    explanation: z.string().describe('A brief explanation of why the quote has the emotional tone.'),
});
export type EmotionalTone = z.infer<typeof EmotionalToneSchema>;

/**
 * Defines the schema for a single identified literary device, including the
 * device name, the quote where it appears, and an explanation.
 */
export const LiteraryDeviceSchema = z.object({
    device: z.string().describe('The name of the literary device.'),
    quote: z.string().describe('The specific quote from the text that uses the device.'),
    explanation: z.string().describe('A brief explanation of how the quote uses the device.'),
});
export type LiteraryDevice = z.infer<typeof LiteraryDeviceSchema>;

/**
 * Defines the schema for the dialogue dynamics analysis, including metrics
 * for power balance and pacing for each character.
 */
export const DialogueDynamicsSchema = z.object({
  powerBalance: z.array(z.object({
    character: z.string(),
    metrics: z.object({
      dialogueTurns: z.number().describe('Total number of times the character speaks.'),
      wordCount: z.number().describe('Total number of words spoken by the character.'),
      questionsAsked: z.number().describe('Number of questions the character asked.'),
      assertionsMade: z.number().describe('Number of assertive or declarative statements made.'),
    }),
  })).describe('An analysis of the power balance between characters.'),
  pacing: z.object({
    overallWordsPerTurn: z.number().describe('The average number of words per turn for the entire dialogue.'),
    characterPacing: z.array(z.object({
        character: z.string(),
        wordsPerTurn: z.number().describe('The average number of words per turn for this specific character.')
    })),
  }).describe('An analysis of the dialogue pacing.'),
  summary: z.string().describe('A brief, insightful summary of the overall dialogue dynamics, including who is driving the conversation.'),
});
export type DialogueDynamics = z.infer<typeof DialogueDynamicsSchema>;


/**
 * Defines the schema for the trope inversion analysis.
 */
export const TropeSchema = z.object({
  trope: z.string().describe('The name of the identified literary trope (e.g., "The Chosen One").'),
  quote: z.string().describe('The specific quote from the text that exemplifies the trope.'),
  inversionSuggestion: z.string().describe('A creative suggestion for how to subvert or invert the trope.'),
});
export type Trope = z.infer<typeof TropeSchema>;


/**
 * Defines the schema for a single chat message in the Actor's Studio.
 */
export const ChatMessageSchema = z.object({
    isUser: z.boolean(),
    message: z.string(),
});
export type ChatMessage = z.infer<typeof ChatMessageSchema>;

/**
 * Defines the schema for narrator bias modes.
 */
export const NarratorBiasSchema = z.enum([
    "Neutral",
    "Jealous of Main Character",
    "Secretly the Villain",
    "Admires Main Character",
    "Completely Unreliable",
    "Hides a Key Fact"
]);
export type NarratorBias = z.infer<typeof NarratorBiasSchema>;

/**
 * Defines the schema for a single segment used in pacing analysis.
 */
export const PacingSegmentSchema = z.object({
  type: z.enum(['Dialogue', 'Narration']).describe('The type of the segment.'),
  wordCount: z.number().describe('The number of words in this segment.'),
});
export type PacingSegment = z.infer<typeof PacingSegmentSchema>;

/**
 * Defines the schema for a "Show, Don't Tell" suggestion.
 */
export const ShowDontTellSuggestionSchema = z.object({
  tellingSentence: z.string().describe("The original sentence from the text that is 'telling' the emotion or event."),
  showingSuggestion: z.string().describe("A rewritten paragraph that 'shows' the same concept through action, description, and internal thought."),
});
export type ShowDontTellSuggestion = z.infer<typeof ShowDontTellSuggestionSchema>;

/**
 * Defines the schema for an identified consistency issue.
 */
export const ConsistencyIssueSchema = z.object({
  issue: z.string().describe("A concise description of the consistency issue found."),
  quote: z.string().describe("The specific quote from the text where the inconsistency is most apparent."),
  explanation: z.string().describe("A brief explanation of why this is a potential consistency problem."),
});
export type ConsistencyIssue = z.infer<typeof ConsistencyIssueSchema>;


/**
 * Defines the schema for an identified piece of subtext.
 */
export const SubtextAnalysisSchema = z.object({
  dialogue: z.string().describe("The original line of dialogue."),
  character: z.string().describe("The character speaking the line."),
  literalMeaning: z.string().describe("The surface-level, literal meaning of the dialogue."),
  subtext: z.string().describe("The unspoken, underlying meaning or emotion behind the line."),
  explanation: z.string().describe("A brief explanation of how the context clues point to this subtext."),
});
export type SubtextAnalysis = z.infer<typeof SubtextAnalysisSchema>;


/**
 * Defines the schema for the perspective shifter tool.
 */
export const PerspectiveSchema = z.object({
  character: z.string().describe("The character whose perspective was adopted."),
  role: z.enum(['Protagonist', 'Antagonist']).describe("The role this character was cast in for the summary."),
  summary: z.string().describe("The summary of the story, rewritten from the character's new perspective."),
});
export type Perspective = z.infer<typeof PerspectiveSchema>;


/**
 * Defines the schema for a single sound effect cue identified by the AI.
 */
export const SoundEffectSchema = z.object({
  segmentIndex: z.number().describe("The zero-based index of the narrative segment where the sound occurs."),
  description: z.string().describe("The description of the sound event from the text (e.g., 'a door creaked open')."),
  soundQuery: z.string().describe("A short search query for a sound effects library (e.g., 'door creak')."),
});
export type SoundEffect = z.infer<typeof SoundEffectSchema>;


/**
 * Defines the schema for a single word in a TTS transcript, including timing.
 */
export const TranscriptWordSchema = z.object({
  word: z.string(),
  startTime: z.number(),
  endTime: z.number(),
});
export type TranscriptWord = z.infer<typeof TranscriptWordSchema>;

/**
 * Defines the schema for a segment's transcript, linking it back to the original segment
 * and providing overall timing for precise highlighting.
 */
export const TranscriptSegmentSchema = z.object({
  segmentIndex: z.number(),
  words: z.array(TranscriptWordSchema),
  startTime: z.number(),
  endTime: z.number(),
});
export type TranscriptSegment = z.infer<typeof TranscriptSegmentSchema>;
